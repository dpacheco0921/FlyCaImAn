function batch_tiff2mat(FolderName, FileName, iparams)
% batch_tiff2mat: extract data from tiffs (generated by scanimage)
%
% Usage:
%   batch_tiff2mat(FolderName, FileName, iparams)
%
% Args:
%   FolderName: name of folders to load
%   FileName: name of files to load
%   iparams: parameters to update
%       (FieldOfView: default 768um, set for this setup)
%       (cDir: directory)
%       (ch2save: channels to save)
%           (1, red)
%           (2, green)
%       (SpMode: main string used for all preprocesing steps it basically
%           sets:
%           (data dimensions: 2DxT, 3DxT, or 3D)
%           (type of stimuli delivered: _song, _opto)
%           (for opto only: which code was used prv or LEDcontroler: _prv, 
%               (otherwise it assumes it used LEDcontroler))
%           (for song: we only used prv)
%           (version of tiff: _old, (otherwise it assumes it is the new version))
%           (type of axial device: 'piezo', 'remotefocus')
%               examples: 2DxT_song_prv, 3DxT_song_prv, 3DxT_opto_prv, 3DxT_opto
%       (Zres: space between planes, 1 um)
%       (pixelsym: flag for pixel symmetry)
%           (0, asymmetric)
%           (1, symmetric)
%       (fStrain: append animal strain to metadata)
%           ([])
%       (region2crop: Y and X coordinates to use from whole FOV)
%           ([])
%       (fs_stim: sampling rate of stimuli related traces)
%           (10^4)
%       (fileformat: format of files to look for)
%           ('.tif', default)
%       %%%%%%%%%%%% video settings %%%%%%%%%%%%
%       (vquality: video quality)
%       (frate: frame rate)
%       (cmap: foreground image colormap)
%       (range: intensity range for each type of video)
%       (axisratio: axis ratio to use, see variable within 'slice3Dmatrix')
%       %%%%%%%%%%%% DF calculation %%%%%%%%%%%%
%       (baseline_tp: baseline timepoints)
%       (sign2use: use positive or negative changes (by multipliying it by 1/-1))
%           (default, 0 (absolute))
%           (-1 (negative))
%           (0 (absolute))
%       (df_flag: flag to calculate DF (if 1), or DF/Fo otherwise)
%           (default, [0 1 2] (get all))
%           (0 (get DF/Fo))
%           (1 (get DF))
%           (2 (get Max F))
%       (ch2plot: channels to use for videos)
%           (default, [], does not plot any videos)
%           (1, red)
%           (2, green)
%       (chunk_size: size of chunks)
%       %%%%%%%%%%%% parpool & server related %%%%%%%%%%%%
%       (serId: server id)
%           (default, 'int')
%       (corenum: number of cores)
%           (default, 4)
%       %%%%%%%%%%%% histogram related %%%%%%%%%%%%
%       (hbins: range to generate histogram plot)
%       (oDir: directory where to save histogram plot)
%
% Notes:
% this function assumes tiff files have the following structure:
%   (year|month|day)_animalnum_(trial/rep)num_'*'.tif ('*' refers to any
%       integer), beware scanimage starts counting from 0. (see demo)
% this function generates *_rawdata.mat and *_metadata.mat
%   *_rawdata.mat: has a Data variable with dimensions:
%       (y (rows/lines), x (columns/pixels per line), z, time, pmt) 
%   *_metadata.mat: is populated with imaging structure variable 'iDat' and
%       file/directory structure variable fDat, and initial stimuli
%       structure variable lStim.
%
% iDat: image metadata structure
%   iDat.FrameN: number of planes
%   iDat.StackN: number of timeseries
%   iDat.FrameSize: [heigth, width]
%   iDat.Power: laser power
%   iDat.DelFrames: frames to delete (deprecated)
%   iDat.LEDCorr: flag for LED corrected stacks
%   iDat.MotCorr: flag for motion corrected stacks
%   iDat.histshift: (deprecated)
%   iDat.bsSubs: (deprecated)
%   iDat.XYresmatch: flag for spatially resampled stacks
%   iDat.sSmooth: flag for spatially smoothed stacks
%   iDat.tResample: flag for temporally resampled stacks
%   iDat.tSmooth: flag for temporally smoothed stacks
%   iDat.MetaData: image resolution
%       {'voxelsize', 'y x z', []}
%
% fDat: file or directory metadata structure
%   fDat.FileName: input file name (without suffices '_rawdata.mat' or '.tiff')
%   fDat.FolderOrigin: original data directory
%   fDat.FolderTrace: original main directory
%   fDat.DataType: main string used for all preprocesing
%   fDat.fName: name of all inout tiffs contributing to this mat file
%
% lStim: stimuli related (auditory/opto) metadata structure
%   lStim.fName: file name
%   lStim.fs: default sampling rate (stimuli delivery)
%   lStim.trialn: number of trials delivered 
%   lStim.fStrain: fly strain / genotype
%   lStim.channels: number of channels recorded
%
% Field of view: needs to be measured per objective or 2P setup
%   using zoom 10 and 256 pixels (width and heigth)
%   motion of 2.1um ~= 7 pixels (~twice the distance calculated for zoom 20)
%   Inter-pixel distance: 0.3, from which you infer voxel size in x and y == 0.3.
%   whole area is then: 768x768 um2 == (voxel size)X(zoom)X(number of pixels)

% default params
tifpars.FieldOfView = 768;
tifpars.cDir = pwd;
tifpars.ch2save = [1 2];
tifpars.SpMode = [];
tifpars.Zres = 1;
tifpars.pixelsym = 0;
tifpars.fStrain = [];
tifpars.region2crop = [];
tifpars.fs_stim = 10^4;
tifpars.fileformat = '.tif';
tifpars.vquality = 100;
tifpars.frate = 10;
tifpars.cmap = parula;
tifpars.range = [0 1; 0 1; 0 1; 0 7];
tifpars.axisratio = 1;
tifpars.baseline_tp = 1:20;
tifpars.sign2use = 0;
tifpars.df_flag = [0 2];
tifpars.ch2plot = [];
tifpars.chunk_size = 10;
tifpars.serverid = 'int';
tifpars.corenumber = 4;
tifpars.hbins = -10^3:3*10^3;
tifpars.oDir = [pwd, filesep, 'rawtiff'];

% internal variables
tifpars.fName = [];
% max spatial resolution to use (round all values smaller than 1/p.sres)
tifpars.sres = 10^4;
tifpars.fo2reject = {'.', '..', 'preprocessed', ...
    'BData', 'rawtiff', 'motcor', 'stitch', ...
    'dfrel_vid', 'smod', 'roicov'};
tifpars.fi2reject = {'rawim.tiff', 'Zstack'};

% update variables
if ~exist('FileName', 'var'); FileName = []; end
if ~exist('FolderName', 'var'); FolderName = []; end
if ~exist('iparams', 'var'); iparams = []; end
tifpars = loparam_updater(tifpars, iparams);

if isempty(tifpars.SpMode)
    fprintf('Error, need to specify SpMode');
    return;
end

fprintf('Running Tiff2Mat\n');

if ~isempty(tifpars.oDir) && ...
        ~exist(tifpars.oDir, 'dir')
    mkdir(tifpars.oDir)
end

% finding folders and filtering out data that is not selected
fo2run = dir;
fo2run = str2match(FolderName, fo2run);
fo2run = str2rm(tifpars.fo2reject, fo2run);
fo2run = {fo2run.name};

fprintf(['Running n-folders : ', num2str(numel(fo2run)), '\n'])

for folder_i = 1:numel(fo2run)
    
    fprintf(['Running folder : ', fo2run{folder_i}, '\n']);
    cd(fo2run{folder_i}); 
    tifpars.Folder2Run = fo2run{folder_i};
    runperfolder(FileName, fo2run{folder_i}, tifpars);
    cd(tifpars.cDir)
    
end

fprintf('... Done\n')

end

function runperfolder(fname, foname, tifpars)
% runperfolder: function that runs all files per directory
%
% Usage:
%   runperfolder(fname, foname, tifpars)
%
% Args:
%   fname: file name
%   foname: folder name
%   tifpars: parameters

% checking files inside folder
[BaseFName, ~, ~] = rdir_namesplit([], ...
    tifpars.fileformat, [], tifpars.fi2reject, fname);
    
if isempty(BaseFName)
    
    fprintf(['*************************************\n ', ...
        'No tiff files in current folder', ...
        ', searching for *.mat metadata files\n', ...
        '*************************************\n '])
    
    tifpars.fileformat = '_vDat.mat';
    [BaseFName, ~, ~] = rdir_namesplit([], ...
        tifpars.fileformat, [], tifpars.fi2reject, fname);
    
    % change smode to generate empty file
    tifpars.SpMode = [tifpars.SpMode, '_notiff'];
    
end

% rdir_namesplit: select all 
%   '(year|month|day)_(animalnum)_(trialnum/repnum)' names
BaseFName = unique(BaseFName); 
fprintf(['Running Folder : ', num2str(foname), ...
    ' (n-exp-types, ', num2str(numel(BaseFName)), ') ,'])

% running each exptype (basename)

% get unique flynum and fly-trials per basename
for basename_i = 1:numel(BaseFName)

    [~, AnimalNum, TrialNum, str_length] = ...
        rdir_namesplit(BaseFName(basename_i), ...
        tifpars.fileformat, [], tifpars.fi2reject, fname);

    % get the number of trials per unique AnimalNum and basename
    for ani_i = unique(AnimalNum)

        TrialPerAnimal = TrialNum(AnimalNum == ani_i);
        str_length_i = str_length(AnimalNum == ani_i, :); 
        
        if isempty(TrialPerAnimal)

            fprintf(['Does not have any file with', ...
                ' flynumber :', num2str(ani_i), ' \n'])

        else

            [Trial2Load, idx2use] = unique(TrialPerAnimal);
            str_length_i = str_length_i(idx2use, :);
            clear idx2use
            
            fprintf([' (n-trials, ', ...
                num2str(unique(TrialPerAnimal)), ')\n']);

            for trial_i = 1:numel(Trial2Load)

                % collapsing all timepoints and z-slices to 1 mat file
                animal_str = sprintf(['%0', ...
                    num2str(str_length_i(trial_i, 2)), 'd'], ani_i);
                trial_str = sprintf(['%0', ...
                    num2str(str_length_i(trial_i, 3)), 'd'], Trial2Load(trial_i));
                
                NameRoot = [BaseFName{basename_i}, '_', ...
                        animal_str, '_', trial_str, '_'];
                
                loadertype(NameRoot, tifpars);

            end 

        end

    end

    clear AnimalNum TrialNum str_length
    
end

end

function loadertype(NameRoot, tifpars)
% loadertype: main tiff2mat function depending on datatype
%
% Usage:
%   loadertype(NameRoot)
%
% Args:
%   NameRoot: basic name of file to load
%   tifpars: parameters

if ~contains(tifpars.SpMode, ...
            'notiff')

    if contains(tifpars.SpMode, 'old')

        % collapsing files with the same animal and trial number to one mat
        %   files (old)
        collect_tiffs_per_exp_trial_old(NameRoot, tifpars);

    elseif contains(tifpars.SpMode, ...
                {'2DxT_single'})

        % saving each file independently
        singleacqcollapser(NameRoot, tifpars);

    else

        % collapsing files with the same animal and trial number to one mat files
        %   for example {'2DxT', '3DxT', '2DxT_song', ...
        %       '3DxT_song', '2DxT_opto', '3DxT_opto', ...
        %       '3DxT_opto_prv'}

        collect_tiffs_per_exp_trial(NameRoot, tifpars)

    end
    
else
   
    % generate empty Data and metadata variables
    % generate metadata
    tifpars.fName = [];
    [fDat, iDat] = generatemetadata(NameRoot(1:end-1), [],  ...
        tifpars.cDir, tifpars.Folder2Run, tifpars.SpMode, ...
        tifpars.Zres, tifpars.sres, ...
        tifpars.FieldOfView, tifpars.fName);

    Data = [];
    save([tifpars.cDir, filesep, ...
        tifpars.Folder2Run, filesep, ...
        fDat.FileName, '_rawdata.mat'], ...
        'Data', '-v7.3')

    % save metadata
    SavingDataNew([], fDat, iDat, 3, ...
        tifpars.cDir, tifpars.Folder2Run, ...
        tifpars.fStrain, tifpars.fs_stim)
    
end

end

function collect_tiffs_per_exp_trial(tif_name, tifpars)
% collect_tiffs_per_exp_trial: collect all tiffs that belong 
%   to a single file and generates the varariable:
%   Data(Y, X, Z, T, Ch) or (Y, X, T, Ch)
%
% Usage:
%   collect_tiffs_per_exp_trial(repname)
%
% Args:
%   repname: name pattern
%   tifpars: parameters

% compiling files with the same animal and trial number to one mat file

% generate mat file names (remove zero padding)
[Basename, AnimalNum, TrialNum, str_length] = ...
        rdir_namesplit(tif_name, ...
        tifpars.fileformat, [], tifpars.fi2reject);
mat_name = [Basename{1}, '_', ...
    num2str(AnimalNum(1)), '_', ...
    num2str(TrialNum(1))];

tif_num = numel(rdir([tif_name, '*.tif']));

% tif start number
if exist([tif_name, ...
        sprintf(['%0', num2str(str_length(1, 4)), 'd'], 0), ...
        '.tif'], 'file')
    start_n = 0;
else
    start_n = 1;
end

% remove last underline
tif_name = tif_name(1:end-1);

Data = [];
tempdata_pre = [];
tempdata = [];

fprintf(['n-repts = ', num2str(tif_num), '\n']) 

% generate matfile to save Data
% overwrite
if exist([tifpars.cDir, filesep, tifpars.Folder2Run, filesep, ...
    mat_name, '_rawdata.mat'], 'file')
    
    delete([tifpars.cDir, filesep, tifpars.Folder2Run, filesep, ...
        mat_name, '_rawdata.mat'])

    try
        delete([tifpars.cDir, filesep, tifpars.Folder2Run, filesep, ...
        mat_name, '_refdata.mat'])
    end

end

dataObj = matfile([tifpars.cDir, filesep, tifpars.Folder2Run, filesep, ...
    mat_name, '_rawdata.mat'], 'Writable', true);

% testing that frames within a tiff file are multiples of channel*stack
status_ = zeros(tif_num, 1);

for tif_i = 1:tif_num
    
    tif_idx = tif_i + start_n - 1;
    tif_idx = sprintf(['%0', num2str(str_length(tif_i, 4)), 'd'], tif_idx);  
    temp_fName = [tif_name, '_', tif_idx];
    
    % tiff2mat_scanimage output is 4D or 3D (Y, X, frame, pmt)
    ImMeta = tiff2mat_getmetadata(temp_fName, tifpars.SpMode, 1);

    status_(tif_i) = mod(ImMeta.frame_num, ImMeta.ChNum*ImMeta.Z);
    
end

clear ImMeta tif_idx

if sum(status_) ~= 0
    fprintf('Error tiff files have uneven number of frames (not matching channel # X number of planes)\n')
end

% importing and concatenating Data on the 3r dim

% dimension to accumulate across tiffs
dim2count = 0;

for tif_i = 1:tif_num
    
    tif_idx = tif_i + start_n - 1;
    tif_idx = sprintf(['%0', num2str(str_length(tif_i, 4)), 'd'], tif_idx);  
    tifpars.fName{1, tif_i} = [tif_name, '_', tif_idx];
    
    try
        % tiff2mat_scanimage output is 4D or 3D (Y, X, frame, pmt)
        [tempdata, ImMeta] = ...
            tiff2mat_scanimage(tifpars.fName{1, tif_i}, tifpars.SpMode, 1);
        
        % crop region
        if ~isempty(tifpars.region2crop)
            y_ = tifpars.region2crop(1):...
                tifpars.region2crop(2);
            x_ = tifpars.region2crop(3):...
                tifpars.region2crop(4);
            ImMeta.X = numel(x_);
            ImMeta.Y = numel(y_);
            tempdata = tempdata(y_, x_, :, :);
            clear y_ x_
        end
        
        % selecting Channel(s) to save
        pmtNum = size(tempdata, 4);

        if pmtNum > 1 % Selecting channel to save
            if length(tifpars.ch2save) < 2
                tempdata = squeeze(tempdata(:, :, :, tifpars.ch2save));
                fprintf(['Collecting just channel ', ...
                    num2str(tifpars.ch2save), '\n'])
            end
        end
        
        % count planes
        if ~isempty(ImMeta.Z)
            ImMeta.FrameNum = ImMeta.Z;
        else
            ImMeta.FrameNum = 1;
        end
       
        % add pre from last tiff
        if ~isempty(tempdata_pre)
            [size(tempdata_pre); size(tempdata)]
            tempdata = cat(3, tempdata_pre, tempdata);
            size(tempdata)
        end
        
        % chop & reshape
        RepeatNum_temp = floor(size(tempdata, 3)/ImMeta.FrameNum);
        siz = size(tempdata);
        if length(siz) == 4
            siz(5) = siz(4);
        end
        siz(3) = ImMeta.FrameNum;
        siz(4) = RepeatNum_temp;

        tempdata_pre = tempdata(:, :, (RepeatNum_temp*ImMeta.FrameNum + 1):end, :);
        tempdata = tempdata(:, :, 1:RepeatNum_temp*ImMeta.FrameNum, :);
        tempdata = reshape(tempdata, siz);
        clear siz

        % concatenate
        siz = size(tempdata);
        
        if ~isempty(tempdata)
            if ImMeta.FrameNum == 1

                if numel(siz) < 5; siz(5) = 1; end

                idx2use = ((dim2count + 1) : (dim2count + siz(4)));

                if siz(5) > 1
                    dataObj.Data(1:siz(1), 1:siz(2), idx2use, 1:siz(5)) ...
                        = squeeze(single(tempdata));
                else
                    dataObj.Data(1:siz(1), 1:siz(2), idx2use) ...
                        = squeeze(single(tempdata));
                end

                dim2count = dim2count + siz(4);

            else

                if numel(siz) < 5; siz(5) = 1; end

                idx2use = ((dim2count + 1) : (dim2count + siz(4)));

                if siz(5) > 1
                    dataObj.Data(1:siz(1), 1:siz(2), 1:siz(3), idx2use, 1:siz(5)) ...
                        = single(tempdata);
                else
                    dataObj.Data(1:siz(1), 1:siz(2), 1:siz(3), idx2use) ...
                        = single(tempdata);
                end

                dim2count = dim2count + siz(4);

            end
        else
            
            if ~isempty(tempdata_pre) && tif_i == tif_num
                fprintf('Last volume/frame is incomplete:\n')
                fprintf(['size of temporal file is ', num2str(size(tempdata_pre)), '\n'])
                fprintf(['original frame N ', num2str(ImMeta.FrameNum), '\n'])
            else
                fprintf('Error - debug\n')
            end
            
        end
        
        clear tempdata;
        
    catch error
        
        keyboard
        
    end
    
    if tif_i == 1
        
        fprintf(['Channels imported: ', ...
            num2str(ImMeta.ChNum), '\n'])
        
        try
            fprintf(['Frame rate: ', ...
                num2str(ImMeta.framerate), '\n']);
        end
        try
            fprintf(['Volume rate: ', ...
                num2str(ImMeta.volumerate), '\n']);
        end
        
    end
    
    fprintf('*');
    if mod(tif_i, 60) == 0 || tif_i == tif_num
        fprintf('\n');
    end
    
end

clear tempdata_pre

% overwrite pixel symmetry flag if not provided by tiff
if ~isfield(ImMeta, 'sympixels') || ...
        (isfield(ImMeta, 'sympixels') && ...
        isempty(ImMeta.sympixels))
   ImMeta.sympixels = tifpars.pixelsym;
end

% Default values for reshape
ImMeta.RepeatNum = dim2count;
ImMeta.DelFrames = [];

data_siz = size(dataObj.Data);
fprintf(['Data final size: ', num2str(data_siz), '\n'])

% generate image and directory metadata
[fDat, iDat] = generatemetadata(mat_name, ImMeta,  ...
    tifpars.cDir, tifpars.Folder2Run, tifpars.SpMode, ...
    tifpars.Zres, tifpars.sres, ...
    tifpars.FieldOfView, tifpars.fName);

% save image and directory metadata
if contains(tifpars.SpMode, 'prv')
    
    % stimuli delivery code using prv (for song or opto)
    SavingDataNew([], fDat, iDat, 3, ...
        tifpars.cDir, tifpars.Folder2Run, ...
        tifpars.fStrain, tifpars.fs_stim)
    
else
    
    % old stimuli delivery code using LEDcontroler
    SavingDataNew([], fDat, iDat, 1, ...
        tifpars.cDir, tifpars.Folder2Run, ...
        tifpars.fStrain, tifpars.fs_stim)
    
end

% collect and plot basic stats
%   maxF and DF video

if ~isempty(tifpars.ch2plot)
    plot_df_per_file(mat_name, tifpars, data_siz)
end

% collect and plot basic stats
%   histogram of each channel
%   trend overtime

plot_hist_and_ftrend_per_file(mat_name, tifpars, iDat, data_siz)

clear Data iDat fDat ImMeta

end

function singleacqcollapser(NameRoot, tifpars)

% collapsing files with the same fly and trial number to one mat files
fprintf(['Running File ', NameRoot])
TemplateFile = rdir([NameRoot, '*.tif']);
TemplateFile = {TemplateFile.name};
clear NameRoot

% Saving each tiff file independently
fprintf([' (n-trials, ', num2str(numel(TemplateFile)), ')\n'])

for acqIdx = 1:numel(TemplateFile)
    
    fprintf(TemplateFile{acqIdx}(1:end-4))
    
    % importing data
    % importing single tiff files
    % tiff2mat_scanimage output is always 4D (X, Y, frame, pmt)
    [Data, ImMeta] = tiff2mat_scanimage(...
        TemplateFile{acqIdx}(1:(end-4)), tifpars.SpMode);
    fprintf([' (Channels, ', num2str(ImMeta.ChNum), ')'])
    
    switch tifpars.SpMode
        case '3D'
            
            % Data is 5D (X, Y, Z, pmt), volumes
            Data = uint16(Data);
            Data = flipdim(Data, 3);
            % deleting first frame (weird projection plane)
            Data = Data(:, :, 2:end, :);
            
        case '2DxT_single'
            
            % Data is 5D (X, Y, Time, pmt)
            Data = uint16(Data);
    end
    
    if ~isfield(ImMeta, 'sympixels') || ...
        (isfield(ImMeta, 'sympixels') && ...
        isempty(ImMeta.sympixels))
        ImMeta.sympixels = tifpars.pixelsym; 
    end
    
    % Selecting channel to save
    pmtNum = size(Data, 4); 
    
    % Selecting channel to save
    if pmtNum > 1
        if length(tifpars.ch2save) < 2
            Data = squeeze(Data(:, :, :, tifpars.ch2save));
            fprintf([' collecting just channel ', num2str(tifpars.ch2save)])
        end
    end
    
    % Metadata
    ImMeta.RepeatNum = 1;
    ImMeta.FrameNum = size(Data, 3);
    [fDat, iDat] = generatemetadata(TemplateFile{acqIdx}(1:(end-4)), ImMeta,  ...
        tifpars.cDir, tifpars.Folder2Run, tifpars.SpMode, ...
        tifpars.Zres, tifpars.sres, ...
        tifpars.FieldOfView, tifpars.fName);
    
    SavingDataNew(Data, fDat, iDat, 1, ...
        tifpars.cDir, tifpars.Folder2Run, ...
        tifpars.fStrain)
    
    clear Data iDat fDat ImMeta
    
    fprintf('\n')
    
end

end

function collect_tiffs_per_exp_trial_old(NameRoot, tifpars)

% collapsing files with the same fly and trial number to one mat files
TemplateFile = rdir([NameRoot, '001.tif']);
TemplateFile = {TemplateFile.name};
TemplateFile = TemplateFile{1};
tiffNumel = numel(rdir([NameRoot, '*.tif']));
clear NameRoot

% Collapsing data from all timepoints to a single matfile
fprintf(['n-repts = ', num2str(tiffNumel), '\n']) 

for RepIdx = 1:tiffNumel
    
    % importing tiff files
    if RepIdx<10
        NumIdx = ['00',num2str(RepIdx)];
    elseif RepIdx > 99
        NumIdx = num2str(RepIdx);
    else 
        NumIdx = ['0',num2str(RepIdx)];
    end
    
    % OptROISeg output is always 4D (X, Y, frame, pmt)
    tifpars.fName{1, RepIdx} = [TemplateFile(1:(end-8)), '_', NumIdx];
    [Data(:, :, :, :, RepIdx), ImMeta] = ...
        tiff2mat_scanimage(tifpars.fName{1, RepIdx}, tifpars.SpMode);
    fprintf('*');
    
    if mod(RepIdx, 60) == 0 || RepIdx == tiffNumel
        fprintf('\n');
    end
    
end

if ~isfield(ImMeta, 'sympixels') || ...
        (isfield(ImMeta, 'sympixels') && ...
        isempty(ImMeta.sympixels))
   ImMeta.sympixels = tifpars.pixelsym; 
end

fprintf('\n')
fprintf(['Channels imported: ',num2str(ImMeta.ChNum),'\n'])

% update RepeatNum
ImMeta.RepeatNum = RepIdx;
ImMeta.FrameNum = size(Data, 3);

% Data is 5D (X, Y, frame, pmt, reps)
Data = permute(Data, [1 2 3 5 4]);
[Data, ImMeta.DelFrames] = zeroframedetect(Data);

% Data is 5D (X, Y, Z, Time, pmt)
eval(['Data = ', ImMeta.Imclass, '(Data);'])

% Selecting channel to save
pmtNum = size(Data, 5); 
if pmtNum > 1
    if length(tifpars.ch2save) < 2
        Data = squeeze(Data(:, :, :, :, tifpars.ch2save));
    end
end

% Metadata
[fDat, iDat] = generatemetadata(TemplateFile(1:(end-8)), ImMeta, ...
    tifpars.cDir, tifpars.Folder2Run, tifpars.SpMode, ...
    tifpars.Zres, tifpars.sres, ...
    tifpars.FieldOfView, tifpars.fName);

SavingDataNew(Data, fDat, iDat, 2, ...
        tifpars.cDir, tifpars.Folder2Run, ...
        tifpars.fStrain, tifpars.fs_stim)
    
clear X Y FrameNum Channels Zoom Data iDat fDat

end

function [Data, Idx] = zeroframedetect(Data)
% zeroframedetect: detect frames with values below greenFThs
%
% Usage:
%   [Data, Idx] = zeroframedetect(Data)
%
% Args:
%   Data: 3D or 4D matrix

siz = size(Data);
greenFThs = 50;
GreenData = Data(:, :, :, :, 2);
maxPixF = squeeze(max(max(GreenData, [], 1), [], 2));
emptyframes = maxPixF <= greenFThs; 
vol2fill = sum(emptyframes, 1) > 0; ...
    vol2fill = find(vol2fill == 1);

if ~isempty(vol2fill)
    
    % volume filling
    Data(:, :, :, :, 2) = OptVolFill(vol2fill, GreenData);
    % get Idx in a 3D version of data arragement
    emptyframes(:, vol2fill) = 1;
    emptyframes = reshape(emptyframes, [prod(siz(3:4)) 1]);
    Idx = find(emptyframes == 1);
    
else
    
    Idx = [];
    
end

end

function [fDat, iDat] = ...
    generatemetadata(ifilename, ImMeta, ...
    cDir, Folder2Run, SpMode, ...
    Zres, sres, FieldOfView, fName)
% generatemetadata: collect image metadata
%
% Usage:
%   [fDat, iDat] = generatemetadata(ifilename, ImMeta, ...
%       cDir, Folder2Run, SpMode, ...
%       Zres, sres, FieldOfView, fName)
%
% Args:
%   ifilename: input filename
%   ImMeta: medatada with dimensions
%   cDir: current directory
%   Folder2Run: file directory
%   SpMode: type of data to run (2DxT, 3DxT, old, new, etc)
%   Zres: space between planes, 1 um
%   sres: max spatial resolution to use (round all values smaller than 1/p.sres)
%       (default, 10^4)
%   FieldOfView: default 768um, set for this setup
%   fName: name of all tiff files contributing to this matfile

if isempty(ImMeta)
    
    fprintf(['ImMeta is empty, generating ', ...
        'arbitrary imaging related params\n']);
    
    % generate fields
    ImMeta.Zoom = NaN;
    ImMeta.sympixels = 1;
    ImMeta.FrameNum = [];
    ImMeta.RepeatNum = [];
    ImMeta.Y = NaN;
    ImMeta.X = NaN;
    ImMeta.Power = NaN;
    ImMeta.DelFrames = [];
    ImMeta.framerate = NaN;
    ImMeta.volumerate = NaN;
    
end

% Loading existing metadata, Load matfile asociated with this tiff file
try
    load([cDir, filesep, Folder2Run, ...
        filesep, ifilename, '_metadata.mat'], 'fDat', 'iDat');
end

% Updating / reseting variables
fDat.FileName = ifilename;
fDat.FolderOrigin = cDir;
fDat.FolderTrace = cDir((max(strfind(cDir, filesep)) + 1):end);
fDat.DataType = SpMode;
fDat.fName = fName;

if ~exist('iDat', 'var')
    fprintf('writing new iDat\n');
    iDat = struct('MetaData', [], 'ZoomFactor', ImMeta.Zoom);
end

% if Zres provided by scanimage then read that value
if isfield(ImMeta, 'Z_stepsiz') && ~isempty(ImMeta.Z_stepsiz)
    Zres = ImMeta.Z_stepsiz;
    fprintf(['Z step size provided by scanimage: ', ...
        num2str(Zres), ' um \n'])
end

% pixel size (symmetric or not)
if ImMeta.sympixels == 0
    
    iDat.MetaData = {'voxelsize', 'y x z', ...
        round([FieldOfView/(ImMeta.Zoom*ImMeta.Y), ...
        FieldOfView/(ImMeta.Zoom*ImMeta.X), ...
        Zres]*sres)/sres};
    
else
    
    iDat.MetaData = {'voxelsize', 'y x z', ...
        round([FieldOfView/(ImMeta.Zoom*ImMeta.X), ...
        FieldOfView/(ImMeta.Zoom*ImMeta.X), ...
        Zres]*sres)/sres};
    
end

% pass variables to iDat
iDat.FrameN = ImMeta.FrameNum;
iDat.StackN = ImMeta.RepeatNum;
iDat.FrameSize = [ImMeta.Y, ImMeta.X]; % [Y, X], [heigth, width]
iDat.Power = ImMeta.Power;
iDat.DelFrames = ImMeta.DelFrames;

% add rate variables (in Hz)
iDat.framerate = ImMeta.framerate;
iDat.volumerate = ImMeta.volumerate;

% reset preprocessing count
iDat.LEDCorr = 0;
iDat.MotCorr = 0;
iDat.histshift = 0;
iDat.bsSubs = 0;
iDat.XYresmatch = 0;
iDat.sSmooth = 0;
iDat.tResample = 0;
iDat.tSmooth = 0;

% remove some fields produced later
f2rem = {'lstEn', 'fstEn', 'GreenChaMean', ...
    'RedChaMean', 'Tres', 'sstEn', ...
    'sSmoothpar', 'PMT_fscore', 'timepointsdel'};

for i = 1:numel(f2rem)
    try iDat = rmfield(iDat, f2rem{i}); end
end

end

function SavingDataNew(Data, fDat, iDat, saveType, ...
    cDir, Folder2Run, ifStrain, fs_stim)
% SavingDataNew: saving both dataand metadata in current folder
%
% Usage:
%   SavingDataNew(Data, fDat, iDat, saveType, ...
%       cDir, Folder2Run, ifStrain)
%
% Args:
%   Data: 3D or 4D matrix
%   fDat: file metadata
%   iDat: image metadata
%   saveType: which input file to read
%   cDir: current directory
%   Folder2Run: file directory
%   ifStrain: input fStrain
%   fs_stim: sampling rate of stimuli related traces

o_file_name_preffix = [cDir, filesep, ...
    Folder2Run, filesep, fDat.FileName];

% save Data
if ~isempty(Data)
    save([cDir, filesep, Folder2Run, filesep, ...
        fDat.FileName, '_rawdata.mat'], 'Data', '-v7.3')
end

% load extra metadata
if saveType == 1
    
    try load([o_file_name_preffix, '.mat'], 'sDat'); end
    
elseif saveType == 2
    
    load([o_file_name_preffix, '_001.mat'], 'sDat');
            
elseif saveType == 3
    
    try load([o_file_name_preffix, '_vDat.mat'], 'rDat', 'logs'); end
    
end

lStim.fName = fDat.FileName;
lStim.fs = [];
lStim.trialn = [];
lStim.fStrain = [];
lStim.channels = [];

% update lStim (using rDat)
if exist('rDat', 'var')
    lStim.fs = rDat.Fs;
    lStim.trialn = numel(rDat.selectedStimulus);
    lStim.channels = rDat.channels;
end

% update lStim (using logs)
if exist('logs', 'var')
    lStim.fStrain = logs.fStrain;
end

% update lStim (using sDat)
if exist('sDat', 'var')
    lStim.fs = sDat.fs;
    lStim.trialn = sDat.trial;
    lStim.fStrain = sDat.fStrain;
    lStim.channels = sDat.channels;
end

% replace/append userdefine fStrain metadata to lStim
if ~isempty(ifStrain)
    lStim.fStrain = ifStrain;
end

if isempty(lStim.fs)
    lStim.fs = fs_stim;
end

% update and save metadata
save([o_file_name_preffix, '_metadata.mat'], ...
    'fDat', 'iDat', 'lStim')

end

function plot_df_per_file(ifilename, tifpars, data_siz)
% plot_df_per_file: plot and save videos of raw data
%
% Usage:
%   plot_df_per_file(ifilename, tifpars, data_siz)
%
% Args:
%   ifilename: file name
%   tifpars: parameters
%   data_siz: data size

image_range = tifpars.range;
video_suffix = {'_MIP_DFoF', '_MIP_DF', '_MIP_maxF', '_MIP_snr'};

if sum(ismember(tifpars.ch2plot, 1))
    
    tifpars.vgate = 1;
    
    % get MIP from raw data
    MIP_proj = get_df_MIP_from_raw([ifilename, '_rawdata.mat'], ...
        [ifilename, '_metadata.mat'], tifpars.baseline_tp, ...
        [], 1, data_siz, [], ...
        tifpars.sign2use, tifpars.df_flag, ...
        tifpars.chunk_size, tifpars.corenumber, ...
        tifpars.serverid);

    % generate videos
    for i = 1:numel(video_suffix)

        if sum(ismember(tifpars.df_flag, i - 1))
            fprintf(['plot ', strrep(video_suffix{i}, '_MIP_', ''), ' (channel = 1) \n'])
            tifpars.range = image_range(i, :);
            tifpars.vname = [tifpars.oDir, filesep, ifilename, [video_suffix{i}, '_1']];
            slice3Dmatrix(flip(MIP_proj{i}, 2), tifpars)
        end

    end
end

if length(data_siz) > 4 && sum(ismember(tifpars.ch2plot, 2))
   
    tifpars.vgate = 1;
    
    % get MIP from raw data
    MIP_proj = get_df_MIP_from_raw([ifilename, '_rawdata.mat'], ...
        [ifilename, '_metadata.mat'], tifpars.baseline_tp, ...
        [], 2, data_siz, [], ...
        tifpars.sign2use, tifpars.df_flag, ...
        tifpars.chunk_size, tifpars.corenumber, ...
        tifpars.serverid);

    % generate videos
    for i = 1:numel(video_suffix)

        if sum(ismember(tifpars.df_flag, i - 1))
            fprintf(['plot ', strrep(video_suffix{i}, '_MIP_', ''), ' (channel = 2) \n'])
            tifpars.range = image_range(i, :);
            tifpars.vname = [tifpars.oDir, filesep, ifilename, [video_suffix{i}, '_2']];
            slice3Dmatrix(flip(MIP_proj{i}, 2), tifpars)
        end

    end
    
end

end

function plot_hist_and_ftrend_per_file(...
    ifilename, tifpars, iDat, data_siz)
% plot_hist_and_ftrend_per_file: plot histogram 
%   and fluorescence over time
%
% Usage:
%   plot_hist_and_ftrend_per_file(...
%       ifilename, tifpars, iDat, data_siz)
%
% Args:
%   ifilename: file name
%   tifpars: parameters
%   iDat: image parameters
%   data_siz: data size

dataObj = matfile([ifilename, '_rawdata.mat']);
time2load = 2:iDat.StackN;
[~, ~, chunk_idx] = ...
        ppool_makechunks(tifpars.chunk_size, ....
        tifpars.corenumber, numel(time2load), 1);
hist_o = [];

% set up parpool
ppobj = setup_parpool(tifpars.serverid, tifpars.corenumber);

% time patches    
for i = 1:numel(chunk_idx)

    if i == 1; t0 = stic; end

    batch2run = chunk_idx{i};

    jobs2run = min([numel(batch2run) tifpars.corenumber]);
    t_idx = cell(jobs2run, 1);
    hist_ = cell(jobs2run, 1);
    f_over_time_ = cell(jobs2run, 1);
    
    parfor ii = 1:numel(batch2run)

        t_idx{ii, 1} = (batch2run(ii):min(batch2run(ii) + ...
            tifpars.chunk_size - 1, numel(time2load)))';
        iv = 1;

        for iii = t_idx{ii, 1}'

            [hist_{ii}(:, :, iv), ...
                f_over_time_{ii}(iv, :)] = ...
                get_hist_and_f_per_timepoint(...
                dataObj, time2load(iii), ...
                length(data_siz), tifpars.hbins);

            iv = iv + 1;

        end

        hist_{ii} = sum(hist_{ii}, 3);
        hist_{ii} = hist_{ii}(:);
    end

    t_idx = cell2mat(t_idx);

    if length(data_siz) == 5 && data_siz(5) > 1
        hist_o(:, :, i) = sum(reshape(cell2mat(hist_), ...
            [numel(tifpars.hbins) data_siz(5) numel(batch2run)]), 3);
    else
        hist_o(:, :, i) = sum(reshape(cell2mat(hist_), ...
            [numel(tifpars.hbins) 1 numel(batch2run)]), 3);        
    end
    f_over_time_o(t_idx, :) = cell2mat(f_over_time_);
    
    if i == 1 
        stocf(t0, 'Time per chunk ');
        fprintf(['Estimated time ', ...
            num2str(stoc(t0)*numel(chunk_idx)/60), ...
            ' minutes\n'])
    end

    if mod(i, 10) == 0
        fprintf('%2.1f%% of chunks completed \n', ...
            i*100/numel(chunk_idx));
    end

end

hist_o = sum(hist_o, 3);

% plot figure
figH = figure('position', genfigpos(1, 'center', [1000 700]));
axH(1) = subplot(2, 2, 1);
axH(2) = subplot(2, 2, 3);
axH(3) = subplot(2, 2, 2);
axH(4) = subplot(2, 2, 4);
color_vect = [1 0 0; 0 0.5 0];

% plot traces
for i = 1:size(hist_o, 2)
    
    lineH(i) = plot(tifpars.hbins, hist_o(:, i), ...
        'Color', color_vect(i, :), ...
        'Parent', axH(1));
    hold(axH(1), 'on')
    
    plot(tifpars.hbins, hist_o(:, i), ...
        'Color', color_vect(i, :), ...
        'Parent', axH(2))
    hold(axH(2), 'on')
    
    plot(f_over_time_o(:, i), ...
        'Color', color_vect(i, :), ...
        'Parent', axH(3))
    hold(axH(3), 'on')

    plot(zscorebigmem(f_over_time_o(:, i)'), ...
        'Color', color_vect(i, :), ...
        'Parent', axH(4))
    hold(axH(4), 'on')
    
    strH{i} = ['cha-', num2str(i)];
    
end

% add labels
axH(1).XLabel.String = 'F (a.u)';
axH(2).XLabel.String = 'F (a.u)';
axH(3).XLabel.String = 'time (stacks)';
axH(4).XLabel.String = 'time (stacks)';

axH(1).YLabel.String = 'Count';
axH(2).YLabel.String = 'Count';
axH(3).YLabel.String = 'F (a.u)';
axH(4).YLabel.String = 'F (Z-score)';

axH(2).YScale = 'log';
axH(1).XLim = tifpars.hbins([1 end]);
axH(2).XLim = tifpars.hbins([1 end]);
axH(3).XLim = [1 size(f_over_time_o, 1)];
axH(4).XLim = [1 size(f_over_time_o, 1)];

legH = legend(axH(1), lineH, strH);

% figure format
figformat = [1 0 0 0 0 0 0 0 1];
resolution_ = '-r300';

% save figure
figEdit(axH, figH);
savefig_int(figH, tifpars.oDir, ...
    [ifilename, '_hist_trend'], figformat, resolution_);
close(figH)

delete_parpool(ppobj);

end

function [hist_, f_over_time_] = ...
    get_hist_and_f_per_timepoint(...
    dataObj, time_idx, n_d, hbins)
% load_process_and_project_Y: load single 
%   stacks and gets histogram and mean signal per channel
%
% Usage:
%   [hist_, f_over_time_] = ...
%   get_hist_and_f_per_timepoint(...
%       dataObj, time_idx, n_d)
%
% Args:
%   dataObj: data object, data is stored at Y.
%   time_idx: timepoints to load.
%   n_d: data dimensions.
%   hbins: range of bins for histogram

temp_i = [];

% load raw data
if n_d == 5
    temp_ = double(dataObj.Data(:, :, :, time_idx, :));
else
    temp_ = double(dataObj.Data(:, :, :, time_idx));
end

if n_d == 5
    
    for i = 1:size(temp_, 5)
        temp_i = temp_(:, :, :, :, i);
        [hist_(:, i), ~] = hist(temp_i(:), hbins);
        f_over_time_(1, i) = mean(temp_i(:));
    end
        
else
    
    temp_i = temp_(:, :, :, :);
    [hist_(:, 1), ~] = hist(temp_i(:), hbins);
    f_over_time_(1, 1) = mean(temp_i(:));
    
end

end

% To delete
% function SavingData(Data, fDat, iDat, saveType)
% 
% global p
% 
% o_file_name_preffix = [p.cDir, filesep, p.Folder2Run, filesep, fDat.FileName];
% 
% % Saving data in current folder
% save([o_file_name_preffix, '_rawdata.mat'], 'Data', '-v7.3')
% 
% % Saving metadata
% if saveType == 1
%     
%     save([o_file_name_preffix, '_metadata.mat'], ...
%         'fDat', 'iDat', '-append')
%     
% else
%     
%     % updates sDat to include names of all the trials used to collapse this file
%     % it assumes that all the other stimuli parameters are the same
%     load([o_file_name_preffix, '_001.mat'], 'sDat');
%     sDat.fName = p.fName;
%     
%     if exist([o_file_name_preffix, '_metadata.mat'], 'file') == 2
%         save([o_file_name_preffix, '_metadata.mat'], ...
%             'fDat', 'iDat', 'sDat', '-append')
%     else
%         save([o_file_name_preffix, '_metadata.mat'], ...
%             'fDat', 'iDat', 'sDat')
%     end
%     
% end
% 
% p.fName = [];
% 
% end
